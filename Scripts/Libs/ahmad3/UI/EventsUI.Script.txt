#Include "Libs/smokegun/Settings.Script.txt" as Settings
#Include "Libs/ahmad3/EventAPI/InGame.Script.txt" as Events
#Include "Libs/ahmad3/EventAPI/Types.Script.txt" as Types
#Include "Libs/smokegun/Constants.Script.txt" as Constants
#Include "Libs/miltant/Nadeo_Fork/Message.Script.txt" as Message
#Include "Libs/smokegun/ObstacleLib.Script.txt" as Obstacle
#Include "Libs/smokegun/Player.Script.txt" as Player

#Include "TextLib" as TL
#Include "MathLib" as ML

#Const Version "2024-07-15"
#Const ScriptName "EventsUI.Script.txt"

#Const C_CE_SelectEvent "obsevents:select_event"
#Const C_CE_ToggleSwitchToEvent "obsevents:toggle_switch_to_event"
#Const C_CE_QuitEvent "obsevents:quit"

#Const C_ML_QuitButtonFrame "Frame_QuitEventButton"
#Const C_ML_QuitBtnBg "Quad_QuitEventButton"
#Const C_ML_QuitBtnLabel "Label_QuitBtn"
#Const C_ML_VoteBtnFrame "Frame_VoteBtn"
#Const C_ML_VoteBtnLabel "Label_VoteBtn"
#Const C_ML_VoteBtnBg "Quad_VoteBtn"
#Const C_ML_ActiveEventBg "Quad_ActiveEventBg"
#Const C_ML_ActiveEventRowHandle "Label_ActiveEventRowHandle"
#Const C_ML_ActiveEventRowEdition "Label_ActiveEventRowEdition"
#Const C_ML_ActiveEventRowName "Label_ActiveEventRowName"
#Const C_ML_ActiveEventRowX "ActiveEvent_Row"
#Const C_ML_SelectedEventFrame "Frame_SelectedEvent"
#Const C_ML_SelectedEventName "Label_SelectedEventName"
#Const C_ML_SelectedEventStartDate "Label_SelectedEventStartD"
#Const C_ML_SelectedEventEndDate "Label_SelectedEventEndD"
#Const C_ML_SelectedEventAuthor "Label_SelectedEventAuthor"
#Const C_ML_SelectedEventIds "Label_SelectedEventIds"
#Const C_ML_SelectedEventUrl "Label_SelectedEventUrl"

#Const C_ML_BorderSize 0.5
#Const C_ML_Size <220., 100.>
#Const C_ML_HeadingSize <220., 12.>
#Const C_ML_FooterSize <220., 12.>
#Const C_ML_SectionWidth 100.
#Const C_ML_ActiveEventRowHeight 6.
#Const C_ML_ActiveEventAmount 10
#Const C_ML_ActiveEventRowHandleWidth 40.
#Const C_ML_LockViewFlex 0.33
#Const C_ML_VoteBtnBorderSize 1
#Const C_ML_BtnOpacity 0.3125
#Const C_ML_SelectedEventTitleHeight 5.
#Const C_ML_EventInfoRowHeight 5.
#Const C_ML_SelectedEventBtnHeight 10.

/**
 * Represents the data of an event in the UI.
 */
#Struct K_EventRow {
    Text Handle;
    Integer Edition;
    Text Name;
}

#Struct K_OptEventRow {
    K_EventRow[] Event;
}

#Struct K_Event {
    K_EventRow Row;
    Text[] Authors;
    Integer StartDate;
    Integer EndDate;
}

#Struct K_VoteInfo {
    Integer Amount;
    Integer Remaining;
}

/**
 * The array containing the votes of each player.
 * The keys are the IDs of the UI configs of the players, and the values are the selected events.
 */
declare K_OptEventRow[Ident] G_VotingToSwitchEvent;

declare K_VoteInfo[K_EventRow] G_Votes;

declare K_VoteInfo G_QuitEventVote;

declare Integer G_PlayerAmount;

//////// Restart behaviors

/**
 * The previous end time that was set before requesting to restart the map.
 *
 * This is used to cancel the map restart if a player finally removed their vote.
 */
declare Integer G_PreviousEndTime;
/**
 * Set to true when a vote for a switch to an event wins.
 */
declare Boolean G_RequestRestart;
/**
 * The next event that players requested a switch to.
 *
 * The content of this is meaningless if [`G_RequestRestart`] is false.
 */
declare K_OptEventRow G_NextEvent;
declare K_OptEventRow G_PlayedEvent;

Boolean Private_OptEventRow_IsPresent(K_OptEventRow _Event) {
    return _Event.Event.count > 0;
}

K_EventRow Private_OptEventRow_Get(K_OptEventRow _Event) {
    assert(Private_OptEventRow_IsPresent(_Event), "OptEventRow must be present before calling Get method");
    return _Event.Event[0];
}

K_OptEventRow Private_OptEventRow_Of(K_EventRow _Event) {
    return K_OptEventRow {
        Event = [_Event]
    };
}

K_OptEventRow Private_OptEventRow_Empty() {
    return K_OptEventRow { Event = [] };
}

Boolean Private_CmpEvents(K_EventRow _A, K_EventRow _B) {
    return _A.Handle == _B.Handle && _A.Edition == _B.Edition;
}

Boolean Private_CmpEvents(K_OptEventRow _A, K_OptEventRow _B) {
    // Return either they're both present with the same value or both null
    return Private_OptEventRow_IsPresent(_A) && Private_OptEventRow_IsPresent(_B)
        && Private_CmpEvents(Private_OptEventRow_Get(_A), Private_OptEventRow_Get(_B))
        || !Private_OptEventRow_IsPresent(_A) && !Private_OptEventRow_IsPresent(_B);
}

Boolean Private_CmpEvents(K_Event _A, K_Event _B) {
    return Private_CmpEvents(_A.Row, _B.Row);
}

Void Private_BeginRestartRequest(K_OptEventRow _Event) {
    declare Integer MessageTime = Settings::GetTimeBeforeSwitchEvent();
    if (Private_OptEventRow_IsPresent(_Event)) {
        declare K_EventRow Event = Private_OptEventRow_Get(_Event);
        Message::SendBigMessage("Switching to " ^ Event.Name ^ "...", MessageTime, 1);
    } else if (Private_OptEventRow_IsPresent(G_PlayedEvent)) {
        declare K_EventRow OldEvent = Private_OptEventRow_Get(G_PlayedEvent);
        Message::SendBigMessage("Quitting " ^ OldEvent.Name ^ "...", MessageTime, 1);
    } else {
        // Do nothing if neither an event is selected nor is running
        return;
    }
    Message::SendStatusMessage(_("Voting has forced a restart of the current Map."), MessageTime, 1);
    G_RequestRestart = True;
    G_NextEvent = _Event;
    G_PreviousEndTime = EndTime;
    EndTime = Now + Settings::GetTimeBeforeSwitchEvent();
}

Void Private_CancelRestartRequest() {
    G_RequestRestart = False;
    EndTime = G_PreviousEndTime;
    Message::CleanBigMessages();
    Message::CleanStatusMessages();
}

/**
 * Checks if the provided event is currently running in the mode.
 *
 * @param _EventHandle the handle of the event to check.
 * @param _EventEdition the edition of the event to check.
 * @return True of the provided event is running, False otherwise.
 */
Boolean Private_IsEventRunning(Text _EventHandle, Integer _EventEdition) {
    return Events::HasEventLoaded()
        && Events::GetEventHandle() == _EventHandle
        && Events::GetEventEdition() == _EventEdition;
}

Void Private_UpdateSelectedEventOf(CUIConfig _UI) {
    declare netwrite K_Event Net_EventsUI_SelectedEvent for _UI = K_Event {};
    declare Text EventHandle = Net_EventsUI_SelectedEvent.Row.Handle;
    declare Integer EventEdition = Net_EventsUI_SelectedEvent.Row.Edition;

    declare netwrite Boolean Net_EventsUI_SelectedEventIsValid for _UI = False;
    declare netwrite Boolean Net_EventsUI_SelectedEventIsRunning for _UI = False;
    declare netwrite K_VoteInfo Net_EventsUI_SelectedEventVote for _UI = K_VoteInfo {};
    declare netwrite Integer Net_EventsUI_SelectedEventUpdate for _UI = -1;

    Net_EventsUI_SelectedEventIsValid = Events::EventHasCurrentMap(EventHandle, EventEdition);
    Net_EventsUI_SelectedEventIsRunning = Private_IsEventRunning(EventHandle, EventEdition);
    Net_EventsUI_SelectedEventVote = G_Votes.get(Net_EventsUI_SelectedEvent.Row, K_VoteInfo {
        Amount = 0,
        Remaining = G_PlayerAmount
    });
    Net_EventsUI_SelectedEventUpdate = Now;
}

/**
 * Updates the selected event for the provided UI.
 *
 * @param _EventHandle the event handle of the event to select.
 * @param _EventEdition the event edition of the event to select.
 * @param _UI the UI to update.
 */
Void Private_UpdateSelectedEvent(Text _EventHandle, Integer _EventEdition, CUIConfig _UI) {
    declare Types::K_EventEditionDetails Event = Events::GetEvents()[_EventHandle].EditionsDetails[_EventEdition];
    declare Text EventName = Event.name;
    if (Event.subtitle != "") {
        EventName ^= " " ^ Event.subtitle;
    }

    declare K_Event SelectedEvent = K_Event {
        Row = K_EventRow {
            Handle = _EventHandle,
            Edition = _EventEdition,
            Name = EventName
        },
        Authors = Event.authors,
        StartDate = Event.start_date,
        EndDate = Event.end_date
    };

    declare netwrite K_Event Net_EventsUI_SelectedEvent for _UI = K_Event {};
    Net_EventsUI_SelectedEvent = SelectedEvent;

    Private_UpdateSelectedEventOf(_UI);
}

Void Private_UnselectAll() {
    foreach (Player in AllPlayers) {
        declare CUIConfig UI <=> UIManager.GetUI(Player);

        declare netwrite Integer Net_EventsUI_SelectedEventUpdate for UI = -1;
        Net_EventsUI_SelectedEventUpdate = -1;
    }
}

/**
 * Updates the selected event for all the players.
 * 
 * @param _EventHandle the event handle of the event to select.
 * @param _EventEdition the event edition of the event to select.
 */
Void Private_UpdateSelectedEvent(Text _EventHandle, Integer _EventEdition) {
    foreach (Player in AllPlayers) {
        declare CUIConfig UI <=> UIManager.GetUI(Player);
        Private_UpdateSelectedEvent(_EventHandle, _EventEdition, UI);
    }
}

K_Event Private_GetSelectedEventOf(CUIConfig _UI) {
    declare netwrite K_Event Net_EventsUI_SelectedEvent for _UI = K_Event {};
    return Net_EventsUI_SelectedEvent;
}

/**
 * Returns the amount of votes needed to switch to the provided event or quit the running event.
 *
 * @param _Vote The current amount of votes.
 * @param _Event The associated event the vote is for. If empty, the vote is for quitting the
 * running event.
 * @return The amount of votes needed to switch to the provided event or quit the running event.
 */
Integer Private_GetRemainingVotesOf(K_VoteInfo _Vote, K_OptEventRow _Event) {
    declare Integer Amount = _Vote.Amount;
    declare Integer Remaining = ML::CeilingInteger(G_PlayerAmount * Settings::GetSwitchEventVotingRatio())
        - Amount;

    if (Amount > 0
        && Remaining <= 0
        && (EndTime == -1 || EndTime - 15000 > Now)
    ) {
        Private_BeginRestartRequest(_Event);
    } else if (Remaining > 0
        && G_RequestRestart
        && Private_CmpEvents(G_NextEvent, _Event)
    ) {
        Private_CancelRestartRequest();
    }

    return Remaining;
}

Void Private_CalcRemainingVotes(K_EventRow _Event) {
    G_Votes[_Event].Remaining = Private_GetRemainingVotesOf(
        G_Votes[_Event],
        Private_OptEventRow_Of(_Event)
    );
}

Void Private_IncreaseVotes(K_EventRow _Event) {
    if (!G_Votes.existskey(_Event)) {
        G_Votes[_Event] = K_VoteInfo {
            Amount = 0,
            Remaining = G_PlayerAmount
        };
    }

    G_Votes[_Event].Amount = ML::Min(G_PlayerAmount, G_Votes[_Event].Amount + 1);
}

Void Private_DecreaseVotes(K_EventRow _Event) {
    G_Votes[_Event].Amount = ML::Max(0, G_Votes[_Event].Amount - 1);
}

Boolean Private_CannotVote(CUIConfig _UI, K_Event _SelectedEvent) {
    declare CSmPlayer Player <=> GetPlayer(_UI);
    if (Player.RequestsSpectate || Spectators.exists(Player)) return True;
    if (_SelectedEvent.Row.Handle == "") return True;
    return False;
}

/**
 * Toggles the vote of switch to an event for the provided user UI config.
 *
 * @param _UI the associated UI that triggered this.
 */
Void Private_ToggleSwitchToEventFor(CUIConfig _UI) {
    declare K_Event SelectedEvent = Private_GetSelectedEventOf(_UI);
    if (Private_CannotVote(_UI, SelectedEvent)) return;

    declare Text EventHandle = SelectedEvent.Row.Handle;
    declare Integer EventEdition = SelectedEvent.Row.Edition;

    if (!Events::EventHasCurrentMap(EventHandle, EventEdition)) {
        // Make sure that the selected event is playable for the current map.
        return;
    }

    if (G_VotingToSwitchEvent.existskey(_UI.Id)
        && Private_OptEventRow_IsPresent(G_VotingToSwitchEvent[_UI.Id])
        && Private_CmpEvents(Private_OptEventRow_Get(G_VotingToSwitchEvent[_UI.Id]), SelectedEvent.Row)
    ) {
        G_VotingToSwitchEvent.removekey(_UI.Id);
        Private_DecreaseVotes(SelectedEvent.Row);
    } else if (!Private_IsEventRunning(EventHandle, EventEdition)) {
        G_VotingToSwitchEvent[_UI.Id] = Private_OptEventRow_Of(SelectedEvent.Row);
        Private_IncreaseVotes(SelectedEvent.Row);
    }

    Private_CalcRemainingVotes(SelectedEvent.Row);

    // Notify the UIs of the vote change
    foreach (Player in AllPlayers) {
        declare CUIConfig UI <=> UIManager.GetUI(Player);
        declare netwrite K_Event Net_EventsUI_SelectedEvent for UI = K_Event {};
        if (!Private_CmpEvents(Net_EventsUI_SelectedEvent, SelectedEvent)) continue;
        declare netwrite K_VoteInfo Net_EventsUI_SelectedEventVote for UI = K_VoteInfo {};
        Net_EventsUI_SelectedEventVote = G_Votes[SelectedEvent.Row];
    }
}

Void Private_IncreaseQuitVotes() {
    G_QuitEventVote.Amount = ML::Min(G_PlayerAmount, G_QuitEventVote.Amount + 1);
}

Void Private_DecreaseQuitVotes() {
    G_QuitEventVote.Amount = ML::Max(0, G_QuitEventVote.Amount - 1);
}

Void Private_CalcRemainingQuitVotes() {
    G_QuitEventVote.Remaining = Private_GetRemainingVotesOf(G_QuitEventVote, Private_OptEventRow_Empty());
}

Void Private_HandeQuitEventFor(CUIConfig _UI) {
    declare K_Event SelectedEvent = Private_GetSelectedEventOf(_UI);
    if (Private_CannotVote(_UI, SelectedEvent)) return;

    declare Text EventHandle = SelectedEvent.Row.Handle;
    declare Integer EventEdition = SelectedEvent.Row.Edition;

    if (!Private_IsEventRunning(EventHandle, EventEdition)) return;

    if (G_VotingToSwitchEvent.existskey(_UI.Id)) {
        G_VotingToSwitchEvent.removekey(_UI.Id);
        Private_DecreaseQuitVotes();
    } else {
        G_VotingToSwitchEvent[_UI.Id] = Private_OptEventRow_Empty();
        Private_IncreaseQuitVotes();
    }

    Private_CalcRemainingQuitVotes();

    // Notify the UIs of the quit vote change
    foreach (Player in AllPlayers) {
        declare CUIConfig UI <=> UIManager.GetUI(Player);
        declare netwrite K_Event Net_EventsUI_SelectedEvent for UI = K_Event {};
        if (!Private_CmpEvents(Net_EventsUI_SelectedEvent, SelectedEvent)) continue;
        declare netwrite K_VoteInfo Net_EventsUI_QuitEventVote for UI = K_VoteInfo {};
        Net_EventsUI_QuitEventVote = G_QuitEventVote;
    }
}

/**
 * Updates the active events panel for all UIs.
 */
Void UpdateActiveEvents() {
    declare Events = Events::GetEvents();
    declare netwrite K_EventRow[] Net_EventsUI_Events for Teams[0] = [];

    // Clear the array then fill it with the `Events` lib data
    Net_EventsUI_Events = [];
    foreach (EventHandle => Event in Events) {
        foreach (Edition in Event.EditionsDetails) {
            declare Text EventName = Edition.name;
            if (TL::Length(Edition.subtitle) > 0) {
                EventName ^= " " ^ Edition.subtitle;
            }

            Net_EventsUI_Events.add(K_EventRow {
                Handle = EventHandle,
                Edition = Edition.id,
                Name = EventName
            });

            if (Events::GetEventHandle() == EventHandle && Events::GetEventEdition() == Edition.id) {
                Private_UpdateSelectedEvent(EventHandle, Edition.id);
            }
        }
    }

    declare netwrite Integer Net_EventsUI_EventsUpdate for Teams[0] = -1;
    Net_EventsUI_EventsUpdate = Now;
}

/**
 * Initializes the UIs of everyone.
 */
Void Init() {
    Private_UnselectAll();
    UpdateActiveEvents();
    G_PlayerAmount = 0;
    G_VotingToSwitchEvent = [];
    G_Votes = [];
    G_RequestRestart = False;

    if (Events::HasEventLoaded()) {
        declare Text EventName = Events::CurrentEdition().name;
        if (Events::CurrentEdition().subtitle != "") {
            EventName ^= " " ^ Events::CurrentEdition().subtitle;
        }

        G_PlayedEvent = Private_OptEventRow_Of(K_EventRow {
            Handle = Events::GetEventHandle(),
            Edition = Events::GetEventEdition(),
            Name = EventName
        });
    }
}

Void HandleCustomEvent(CUIConfigEvent _Event) {
    assert(_Event.Type == CUIConfigEvent::EType::OnLayerCustomEvent);
    switch (_Event.CustomEventType) {
        case C_CE_SelectEvent: {
            declare Text EventHandle = _Event.CustomEventData[0];
            declare Integer EventEdition = TL::ToInteger(_Event.CustomEventData[1]);

            Private_UpdateSelectedEvent(EventHandle, EventEdition, _Event.UI);
        }

        case C_CE_ToggleSwitchToEvent: {
            Private_ToggleSwitchToEventFor(_Event.UI);
        }

        case C_CE_QuitEvent: {
            Private_HandeQuitEventFor(_Event.UI);
        }
    }
}

Void Loop() {
    if (Players.count != G_PlayerAmount) {
        G_PlayerAmount = Players.count;
        declare netwrite Integer Net_EventsUI_PlayerAmount for Teams[0] = 0;
        Net_EventsUI_PlayerAmount = G_PlayerAmount;

        // Remove the votes of the missing players

        declare Ident[] VotesToRemove;

        foreach (Id => Event in G_VotingToSwitchEvent) {
            declare Boolean Found = False;

            foreach (Player in Players) {
                declare CUIConfig UI <=> UIManager.GetUI(Player);
                if (Id == UI.Id) {
                    Found = True;
                    break;
                }
            }

            if (Found) continue;

            if (Private_OptEventRow_IsPresent(Event)) {
                Private_DecreaseVotes(Private_OptEventRow_Get(Event));
            } else {
                Private_DecreaseQuitVotes();
            }

            VotesToRemove.add(Id);
        }

        foreach (Id in VotesToRemove) {
            G_VotingToSwitchEvent.removekey(Id);
        }

        Private_CalcRemainingQuitVotes();
        foreach (Event => Vote in G_Votes) {
            Private_CalcRemainingVotes(Event);
        }

        // Players who voted for an event then went spectator need their selected event vote amount
        // to be updated, so we update their UIs.

        foreach (Player in AllPlayers) {
            if (!Player.RequestsSpectate || !Spectators.exists(Player)) continue;
            declare CUIConfig UI <=> UIManager.GetUI(Player);
            Private_UpdateSelectedEventOf(UI);
        }
    }
}

Void BeginRestartMap() {
    Private_CancelRestartRequest();

    if (Private_OptEventRow_IsPresent(G_NextEvent)) {
        // The players voted for a switch to an event

        // Play the event
        declare K_EventRow Event = Private_OptEventRow_Get(G_NextEvent);
        Events::SetEventHandle(Event.Handle);
        Events::SetEventEdition(Event.Edition);
        Events::LoadEdition();

        // Remove the votes of the player who voted for this event

        declare Ident[] VotesToRemove = [];

        foreach (Id => VotedEvent in G_VotingToSwitchEvent) {
            if (Private_OptEventRow_IsPresent(VotedEvent)
                && Private_CmpEvents(Private_OptEventRow_Get(VotedEvent), Event)
            ) {
                VotesToRemove.add(Id);
            }
        }

        foreach (Id in VotesToRemove) {
            G_VotingToSwitchEvent.removekey(Id);
        }

        // Reset the vote amount to quit the current event and to switch to this event

        G_QuitEventVote.Amount = 0;
        G_Votes[Event].Amount = 0;
        Private_CalcRemainingQuitVotes();
        foreach (Player in AllPlayers) {
            declare CUIConfig UI <=> UIManager.GetUI(Player);

            declare netwrite K_VoteInfo Net_EventsUI_QuitEventVote for UI = K_VoteInfo {};
            Net_EventsUI_QuitEventVote = G_QuitEventVote;

            declare netwrite K_VoteInfo Net_EventsUI_SelectedEventVote for UI = K_VoteInfo {};
            Net_EventsUI_SelectedEventVote = G_Votes[Event];
        }
    } else {
        // The players voted for quitting the current event

        Events::ClearSelectedEvent();

        // Remove the votes of the player who voted to quit

        declare Ident[] VotesToRemove = [];

        foreach (Id => VotedEvent in G_VotingToSwitchEvent) {
            if (Private_OptEventRow_IsPresent(VotedEvent)) continue;
            VotesToRemove.add(Id);
        }

        foreach (Id in VotesToRemove) {
            G_VotingToSwitchEvent.removekey(Id);
        }

        foreach (Player in AllPlayers) {
            declare CUIConfig UI <=> UIManager.GetUI(Player);
            Private_UpdateSelectedEventOf(UI);
        }
    }

    G_PlayedEvent = G_NextEvent;
}

Void EndRestartMap() {
    // Reset all the players
    foreach (Player in Players) {
        Player::setInitialized(Player, False);
        Player::InitPlayer(Player);
        Obstacle::ObsRespawnPlayer(Player, True);
    }

    // This will select the played event (if present) to the players
    UpdateActiveEvents();
}

Boolean Private_ViewIsLocked() {
    return Settings::GetLockEventsUI();
}

Text Private_GetVoteBtn(Vec2 _Size, Boolean _Locked) {
    declare Text BtnText = "";
    declare Text QuadScriptEventsAttr = "scriptevents=\"1\"";
    if (_Locked) {
        BtnText = "You cannot vote.";
        QuadScriptEventsAttr = "";
    }

    return """
<quad
    z-index="-1"
    id="{{{C_ML_VoteBtnBg}}}"
    valign="center"
    halign="center"
    bgcolor="FFF"
    opacity="{{{C_ML_BtnOpacity}}}"
    size="{{{_Size.X}}} {{{_Size.Y}}}"
    data-hover-opacity="{{{C_ML_BtnOpacity * 1.3}}}"
    {{{QuadScriptEventsAttr}}}
/>
<label
    id="{{{C_ML_VoteBtnLabel}}}"
    text="{{{BtnText}}}"
    halign="center"
    valign="center2"
/>
    """;
}

Text Private_GetFooter() {
    // The server owner locked the events manager UI
    if (Private_ViewIsLocked()) {
        return """
<!-- The locked view UI -->
<frame pos="{{{-C_ML_FooterSize.X / 2 + C_ML_FooterSize.X * C_ML_LockViewFlex / 2}}} 0">
    <label text="🔒 This view is locked." halign="center" valign="center2" />
</frame>
<!-- The button wrapper -->
<frame id="{{{C_ML_VoteBtnFrame}}}" pos="{{{C_ML_FooterSize.X / 2 - C_ML_FooterSize.X * (1 - C_ML_LockViewFlex) / 2}}}">
    {{{Private_GetVoteBtn(
        <
            C_ML_FooterSize.X * (1 - C_ML_LockViewFlex) - C_ML_VoteBtnBorderSize * 2,
            C_ML_FooterSize.Y - C_ML_VoteBtnBorderSize * 2
        >,
        True
    )}}}
</frame>
        """;
    }

    return """
<frame id="{{{C_ML_VoteBtnFrame}}}" hidden="1">
    {{{Private_GetVoteBtn(
        <
            C_ML_FooterSize.X - C_ML_VoteBtnBorderSize * 2,
            C_ML_FooterSize.Y - C_ML_VoteBtnBorderSize * 2
        >,
        False
    )}}}
</frame>
    """;
}

Text Private_GetActiveEventRows(Text _ModelId) {
    declare Text Out = "";
    for (Idx, 0, C_ML_ActiveEventAmount - 1) {
        Out ^= """<frameinstance
            modelid="{{{_ModelId}}}"
            id="{{{C_ML_ActiveEventRowX}}}{{{Idx}}}"
            pos="0 {{{-C_ML_ActiveEventRowHeight * Idx}}}"
        />""";
    }
    return Out;
}

Text Private_GetWidget() {
    declare Text Footer = """
<!-- Background -->
<quad
    bgcolor="FFF2"
    size="{{{C_ML_FooterSize.X}}} {{{C_ML_FooterSize.Y}}}"
    halign="center"
    valign="center"
/>
{{{Private_GetFooter()}}}
    """;

    declare Real SectionHeight = C_ML_ActiveEventRowHeight * C_ML_ActiveEventAmount;

    // The gap between a section and the heading
    declare Real SectionVGap = (C_ML_Size.Y - C_ML_HeadingSize.Y - C_ML_FooterSize.Y - SectionHeight) / 4;

    return """
<frame id="Frame_EventsUI" hidden="1">
    <!-- Background -->
    <quad
        z-index="-1"
        halign="center"
        valign="center"
        size="{{{C_ML_Size.X}}} {{{C_ML_Size.Y}}}"
        bgcolor="000000CC"
    />

    <!-- Heading -->
    <frame pos="0 {{{C_ML_Size.Y / 2 - C_ML_HeadingSize.Y / 2}}}">
        <!-- Background -->
        <quad
            bgcolor="FFF2"
            size="{{{C_ML_HeadingSize.X}}} {{{C_ML_HeadingSize.Y}}}"
            halign="center"
            valign="center"
        />
        <label
            text="Events manager"
            pos="0 {{{-C_ML_BorderSize}}}"
            halign="center"
            valign="center2"
            textcolor="FFFFFFFF"
            textalign="center"
            textfont="Oswald"
            textsize="9"
            style="TextTitle3"
            textemboss="1"
        />
    </frame>

    <!-- Content -->
    <frame>
        <!-- Active events -->
        <frame pos="{{{-C_ML_Size.X / 4}}} {{{-SectionVGap / 2}}}">
            <framemodel id="Row">
                <frame pos="0 {{{-C_ML_ActiveEventRowHeight / 2}}}">
                    <!-- Background -->
                    <quad
                        z-index="-1"
                        bgcolor="000" opacity="{{{C_ML_BtnOpacity}}}"
                        id="{{{C_ML_ActiveEventBg}}}"
                        size="{{{C_ML_SectionWidth - C_ML_BorderSize}}} {{{C_ML_ActiveEventRowHeight - C_ML_BorderSize}}}"
                        valign="center" halign="center"
                        scriptevents="1"
                    />

                    <frame pos="{{{-C_ML_SectionWidth / 2}}} 0">
                        <label
                            id="{{{C_ML_ActiveEventRowHandle}}}"
                            text="<event_handle>"
                            pos="{{{C_ML_BorderSize * 2}}} 0"
                            halign="left"
                            valign="center2"
                        />
                    </frame>
                    <frame pos="{{{-C_ML_SectionWidth / 2 + C_ML_ActiveEventRowHandleWidth}}} 0">
                        <label
                            id="{{{C_ML_ActiveEventRowEdition}}}"
                            text="X"
                            halign="left"
                            valign="center2"
                        />
                    </frame>
                    <frame pos="{{{C_ML_SectionWidth / 2}}} 0">
                        <label
                            id="{{{C_ML_ActiveEventRowName}}}"
                            text="<event_name>"
                            pos="{{{-C_ML_BorderSize * 2}}} 0"
                            halign="right"
                            valign="center2"
                        />
                    </frame>
                </frame>
            </framemodel>

            <!-- Heading -->
            <frame pos="0 {{{C_ML_Size.Y / 2 - C_ML_HeadingSize.Y - SectionVGap}}}">
                <label text="Active events" halign="center" valign="center2" />
            </frame>

            <!-- Table -->
            <frame pos="0 {{{SectionHeight / 2}}}">
                {{{Private_GetActiveEventRows("Row")}}}
            </frame>

            <!-- Background -->
            <quad
                bgcolor="FFF1"
                halign="center"
                valign="center"
                size="{{{C_ML_SectionWidth}}} {{{SectionHeight}}}"
            />
        </frame>

        <!-- Selected event -->
        <frame
            id="{{{C_ML_SelectedEventFrame}}}"
            pos="{{{C_ML_Size.X / 4}}} {{{-SectionVGap / 2}}}"
            hidden="1"
        >
            <!-- Heading -->
            <frame pos="0 {{{C_ML_Size.Y / 2 - C_ML_HeadingSize.Y - SectionVGap}}}">
                <label text="Selected event" halign="center" valign="center2" />
            </frame>

            <!-- Background -->
            <quad
                bgcolor="FFF1"
                halign="center"
                valign="center"
                size="{{{C_ML_SectionWidth}}} {{{SectionHeight}}}"
            />

            <!-- Title -->
            <frame pos="0 {{{SectionHeight / 2 - C_ML_SelectedEventTitleHeight / 2}}}">
                <label
                    id="{{{C_ML_SelectedEventName}}}"
                    text="LoL Cup #2"
                    halign="left"
                    valign="center2"
                    size="{{{C_ML_SectionWidth - C_ML_BorderSize * 2}}} {{{C_ML_SelectedEventTitleHeight}}}"
                    pos="{{{-C_ML_SectionWidth / 2 + C_ML_BorderSize}}} {{{-C_ML_BorderSize}}}"
                />

                <!-- Background -->
                <quad
                    bgcolor="FFF2"
                    size="{{{C_ML_SectionWidth}}} {{{C_ML_SelectedEventTitleHeight + C_ML_BorderSize * 2}}}"
                    pos="0 {{{-C_ML_BorderSize}}}"
                    valign="center"
                    halign="center"
                />
            </frame>

            <!-- Event IDs -->
            <frame
                pos="{{{C_ML_SectionWidth / 2 - C_ML_BorderSize}}} {{{SectionHeight / 2 - C_ML_SelectedEventTitleHeight - C_ML_BorderSize * 3}}}"
            >
                <label
                    id="{{{C_ML_SelectedEventIds}}}"
                    text="lol_cup/2"
                    halign="right"
                    valign="top"
                    size="{{{C_ML_SectionWidth}}} {{{C_ML_SelectedEventTitleHeight / 2}}}"
                />
            </frame>

            <!-- Event info -->
            <frame pos="{{{-C_ML_SectionWidth / 2 + C_ML_BorderSize}}} {{{SectionHeight / 2 - C_ML_SelectedEventTitleHeight * 2 - C_ML_BorderSize * 3}}}">
                <label
                    id="{{{C_ML_SelectedEventAuthor}}}"
                    text="Atria Triss"
                    textprefix="By: "
                    halign="left"
                    valign="center2"
                    size="{{{C_ML_SectionWidth}}} {{{C_ML_EventInfoRowHeight}}}"
                    pos="0 {{{-C_ML_EventInfoRowHeight * 0}}}"
                />
                <label
                    id="{{{C_ML_SelectedEventStartDate}}}"
                    text="17/07/2024 01:14"
                    textprefix="Began at: "
                    halign="left"
                    valign="center2"
                    pos="0 {{{-C_ML_EventInfoRowHeight * 1}}}"
                />
                <label
                    id="{{{C_ML_SelectedEventEndDate}}}"
                    text="17/07/2024 05:14"
                    textprefix="Ends at: "
                    halign="left"
                    valign="center2"
                    pos="0 {{{-C_ML_EventInfoRowHeight * 2}}}"
                />
                <label
                    id="{{{C_ML_SelectedEventUrl}}}"
                    text="$l[{{{Constants::C_WebsiteUrl}}}/event/campaign/2]See the scores"
                    halign="left"
                    valign="center2"
                    pos="0 {{{-C_ML_EventInfoRowHeight * 3}}}"
                />
            </frame>

            <!-- Quit vote button -->
            <frame
                id="{{{C_ML_QuitButtonFrame}}}"
                pos="0 {{{-SectionHeight / 2 + C_ML_SelectedEventBtnHeight / 2}}}"
                hidden="1"
            >
                <!-- Background -->
                <quad
                    id="{{{C_ML_QuitBtnBg}}}"
                    bgcolor="A10" opacity="{{{C_ML_BtnOpacity}}}"
                    halign="center"
                    valign="center"
                    size="{{{C_ML_SectionWidth - C_ML_BorderSize * 2}}} {{{C_ML_SelectedEventBtnHeight - C_ML_BorderSize * 2}}}"
                    data-hover-opacity="{{{C_ML_BtnOpacity * 1.3}}}"
                    z-index="-1"
                    scriptevents="1"
                />

                <label
                    id="{{{C_ML_QuitBtnLabel}}}"
                    text="Quit this event"
                    valign="center2"
                    halign="center"
                />
            </frame>
        </frame>
    </frame>

    <!-- Footer -->
    <frame pos="0 {{{C_ML_FooterSize.Y / 2 - C_ML_Size.Y / 2}}}">
        {{{Footer}}}
    </frame>
</frame>
""";
}

Boolean RequestedRestart() {
    return G_RequestRestart;
}

Text GetLayer() {
    // Used by the script when we select an event to show the quit button
    declare Text ShowQuitBtn = "G_SelectedEventQuitBtnFrame.Show();";
    if (Private_ViewIsLocked()) {
        ShowQuitBtn = "";
    }

    return """
<manialink version="3" name="Obstacle:EventsUI">
    <frame>{{{Private_GetWidget()}}}</frame>
    <script><![CDATA[

#Include "MathLib" as ML
#Include "TextLib" as TL
#Include "TimeLib" as TiL
#Include "ColorLib" as CL

#Struct K_EventRow {
    Text Handle;
    Integer Edition;
    Text Name;
}

#Struct K_Event {
    K_EventRow Row;
    Text[] Authors;
    Integer StartDate;
    Integer EndDate;
}

#Struct K_VoteInfo {
    Integer Amount;
    Integer Remaining;
}

declare K_EventRow[] G_Events;

declare K_Event G_SelectedEvent;
declare Boolean G_SelectedEventIsValid;
declare Boolean G_SelectedEventIsRunning;

declare K_VoteInfo G_Vote;
declare K_VoteInfo G_QuitEventVote;
declare Integer G_TotalPlayers;

declare Boolean G_LockView;

declare CMlFrame G_SelectedEventFrame;
declare CMlFrame G_SelectedEventQuitBtnFrame;
declare CMlLabel G_SelectedEventName;
declare CMlLabel G_SelectedEventStartDate;
declare CMlLabel G_SelectedEventEndDate;
declare CMlLabel G_SelectedEventAuthor;
declare CMlLabel G_SelectedEventIds;
declare CMlLabel G_SelectedEventUrl;

declare CMlFrame G_VoteBtnFrame;
declare CMlLabel G_VoteBtnLabel;
declare CMlQuad G_VoteBtnBg;

declare CMlLabel G_QuitVoteBtnLabel;

CMlLabel GetLabel(Text _Id) {
    return (Page.GetFirstChild(_Id) as CMlLabel);
}

Void InitUIVars() {
    G_VoteBtnFrame <=> (Page.GetFirstChild("{{{C_ML_VoteBtnFrame}}}") as CMlFrame);
    G_VoteBtnLabel <=> GetLabel("{{{C_ML_VoteBtnLabel}}}");
    G_VoteBtnBg <=> (Page.GetFirstChild("{{{C_ML_VoteBtnBg}}}") as CMlQuad);

    G_QuitVoteBtnLabel <=> GetLabel("{{{C_ML_QuitBtnLabel}}}");

    G_SelectedEventFrame <=> (Page.GetFirstChild("{{{C_ML_SelectedEventFrame}}}") as CMlFrame);
    G_SelectedEventQuitBtnFrame <=> (Page.GetFirstChild("{{{C_ML_QuitButtonFrame}}}") as CMlFrame);
    G_SelectedEventName <=> GetLabel("{{{C_ML_SelectedEventName}}}");
    G_SelectedEventStartDate <=> GetLabel("{{{C_ML_SelectedEventStartDate}}}");
    G_SelectedEventEndDate <=> GetLabel("{{{C_ML_SelectedEventEndDate}}}");
    G_SelectedEventAuthor <=> GetLabel("{{{C_ML_SelectedEventAuthor}}}");
    G_SelectedEventIds <=> GetLabel("{{{C_ML_SelectedEventIds}}}");
    G_SelectedEventUrl <=> GetLabel("{{{C_ML_SelectedEventUrl}}}");
}

Void UpdateFrameTab(CUIConfig _UI, CMlPage _Page, Text _TabKey, Text _FrameTabId)
{
    declare netread Boolean _TabsLib_UseTabs for _UI;
    if (! _TabsLib_UseTabs) return;

    declare Boolean _TabsLib_ScoresLayerIsVisible   for _UI;
    declare Boolean _TabsLib_AltLayerIsVisible      for _UI;
    declare Text    _TabsLib_CurrentTab             for _UI;
    declare netread Text _TabsLib_ScoresTableTab    for _UI;

    declare Boolean ShowCurrentTab = _TabsLib_AltLayerIsVisible && (_TabsLib_CurrentTab == _TabKey);

    if (_TabKey == _TabsLib_ScoresTableTab)
    {
        // log("_TabsLib_ScoresTableTab: "^_TabsLib_ScoresTableTab);
        ShowCurrentTab = _TabsLib_ScoresLayerIsVisible ||
            (_TabsLib_AltLayerIsVisible && (_TabsLib_CurrentTab == _TabsLib_ScoresTableTab));
    }

    declare MainFrame <=> (_Page.GetFirstChild(_FrameTabId) as CMlFrame);
    if (MainFrame == Null) return;

    if (ShowCurrentTab) {
        MainFrame.Show();
    } else {
        MainFrame.Hide();
    }
}

Void SelectEvent(Text _EventHandle, Integer _EventEdition) {
    SendCustomEvent({{{dump(C_CE_SelectEvent)}}}, [_EventHandle, "" ^ _EventEdition]);
}

Void HandleSwitchBtnClick() {
    SendCustomEvent({{{dump(C_CE_ToggleSwitchToEvent)}}}, []);
}

Void HandleQuitBtnClick() {
    SendCustomEvent({{{dump(C_CE_QuitEvent)}}}, []);
}

Void UpdateEventList() {
    declare netread K_EventRow[] Net_EventsUI_Events for Teams[0];
    G_Events = Net_EventsUI_Events;

    foreach (Idx => Event in G_Events.slice(0, ML::Min(G_Events.count, {{{C_ML_ActiveEventAmount}}}))) {
        declare CMlFrame RowFrame <=> (Page.GetFirstChild({{{dump(C_ML_ActiveEventRowX)}}} ^ Idx) as CMlFrame);
        declare CMlLabel LabelHandle <=> (RowFrame.GetFirstChild({{{dump(C_ML_ActiveEventRowHandle)}}}) as CMlLabel);
        declare CMlLabel LabelEdition <=> (RowFrame.GetFirstChild({{{dump(C_ML_ActiveEventRowEdition)}}}) as CMlLabel);
        declare CMlLabel LabelName <=> (RowFrame.GetFirstChild({{{dump(C_ML_ActiveEventRowName)}}}) as CMlLabel);

        LabelHandle.SetText(Event.Handle);
        LabelEdition.SetText(Event.Edition ^ "");
        LabelName.SetText(Event.Name);
        RowFrame.Show();
    }

    for (Idx, ML::Min(G_Events.count, 0), {{{C_ML_ActiveEventAmount - 1}}}) {
        declare CMlFrame RowFrame <=> (Page.GetFirstChild({{{dump(C_ML_ActiveEventRowX)}}} ^ Idx) as CMlFrame);
        RowFrame.Hide();
    }
}

Void UpdateSelectedEvent() {
    declare netread K_Event Net_EventsUI_SelectedEvent for UI;
    declare netread Boolean Net_EventsUI_SelectedEventIsValid for UI = False;
    declare netread Boolean Net_EventsUI_SelectedEventIsRunning for UI = False;
    declare netread K_VoteInfo Net_EventsUI_SelectedEventVote for UI;

    G_SelectedEvent = Net_EventsUI_SelectedEvent;
    G_SelectedEventIsValid = Net_EventsUI_SelectedEventIsValid;
    G_SelectedEventIsRunning = Net_EventsUI_SelectedEventIsRunning;
    G_Vote = Net_EventsUI_SelectedEventVote;
}

Void UpdateVoteBtnUI() {
    declare Text Txt = "%1/%2 player(s) voted for a switch to %3 (%4 needed)";
    G_VoteBtnLabel.SetText(TL::Compose(Txt, G_Vote.Amount ^ "", G_TotalPlayers ^ "", G_SelectedEvent.Row.Name, G_Vote.Remaining ^ ""));
}

Void UpdateQuitEventVoteBtnUI() {
    declare Text Txt = "%1/%2 player(s) voted to quit (%3 needed)";
    G_QuitVoteBtnLabel.SetText(TL::Compose(Txt, G_QuitEventVote.Amount ^ "", G_TotalPlayers ^ "", G_QuitEventVote.Remaining ^ ""));
}

Void UpdateSelectedEventUI() {
    if (G_SelectedEvent.Row.Handle == "" && G_SelectedEvent.Row.Edition == -1) {
        G_SelectedEventFrame.Hide();
        G_VoteBtnFrame.Hide();
        return;
    }

    G_SelectedEventName.SetText(G_SelectedEvent.Row.Name);
    G_SelectedEventIds.SetText(G_SelectedEvent.Row.Handle ^ "/" ^ G_SelectedEvent.Row.Edition);
    G_SelectedEventStartDate.SetText(TiL::FormatDate(G_SelectedEvent.StartDate ^ "", TiL::EDateFormats::RelativeShort));
    declare Text UrlText = "$l[{{{Constants::C_WebsiteUrl}}}/event/%1/%2]See the scores";
    G_SelectedEventUrl.SetText(TL::Compose(UrlText, G_SelectedEvent.Row.Handle, G_SelectedEvent.Row.Edition ^ ""));

    if (G_SelectedEvent.EndDate == -1) {
        G_SelectedEventEndDate.Hide();
    } else {
        G_SelectedEventEndDate.SetText(TiL::FormatDate(G_SelectedEvent.EndDate ^ "", TiL::EDateFormats::RelativeShort));
        G_SelectedEventEndDate.Show();
    }

    if (G_SelectedEvent.Authors.count == 0) {
        G_SelectedEventAuthor.Hide();
    } else {
        declare Text AuthorsTxt = "";

        foreach (Idx => Author in G_SelectedEvent.Authors) {
            AuthorsTxt ^= "$<" ^ Author ^ "$>";
            if (Idx < G_SelectedEvent.Authors.count - 1) AuthorsTxt ^= ", ";
        }

        G_SelectedEventAuthor.SetText(AuthorsTxt);
        G_SelectedEventAuthor.Show();
    }

    if (G_SelectedEventIsValid) {
        UpdateVoteBtnUI();
        G_VoteBtnBg.DataAttributeSet("disabled", "0");
        G_VoteBtnBg.BgColor = CL::HexToRgb("3E1");
    } else {
        G_VoteBtnBg.BgColor = CL::HexToRgb("F10");
        G_VoteBtnBg.DataAttributeSet("disabled", "1");
        G_VoteBtnLabel.SetText("This event cannot be played on this map.");
    }

    if (G_SelectedEventIsRunning) {
        {{{ShowQuitBtn}}}
        G_VoteBtnBg.BgColor = CL::HexToRgb("03F");
        G_VoteBtnBg.DataAttributeSet("disabled", "1");
        G_VoteBtnLabel.SetText("Playing " ^ G_SelectedEvent.Row.Name);
        UpdateQuitEventVoteBtnUI();
    } else {
        G_SelectedEventQuitBtnFrame.Hide();
    }

    G_SelectedEventFrame.Show();
    G_VoteBtnFrame.Show();
}

Void HandleClick(CMlQuad _Quad) {
    switch (_Quad.ControlId) {
        case {{{dump(C_ML_ActiveEventBg)}}}: {
            declare Text FrameId = _Quad.Parent.Parent.ControlId;
            declare Integer Idx = TL::ToInteger(
                TL::SubString(FrameId, TL::Length({{{dump(C_ML_ActiveEventRowX)}}}), TL::Length(FrameId))
            );
            declare K_EventRow Selected = G_Events[Idx];
            SelectEvent(Selected.Handle, Selected.Edition);
        }

        case {{{dump(C_ML_QuitBtnBg)}}}: {
            HandleQuitBtnClick();
        }

        case {{{dump(C_ML_VoteBtnBg)}}}: {
            HandleSwitchBtnClick();
        }
    }
}

declare Integer G_EventsUpdate;

Void InitEventsUpdater() {
    declare netread Integer Net_EventsUI_EventsUpdate for Teams[0] = -1;
    G_EventsUpdate = -1;
}

Boolean EventsUpdated() {
    declare netread Integer Net_EventsUI_EventsUpdate for Teams[0] = -1;
    if (G_EventsUpdate != Net_EventsUI_EventsUpdate) {
        G_EventsUpdate = Net_EventsUI_EventsUpdate;
        return True;
    }
    return False;
}

declare Integer G_SelectedEventUpdate;

Void InitSelectedEventUpdater() {
    declare netread Integer Net_EventsUI_SelectedEventUpdate for UI = -1;
    G_SelectedEventUpdate = -1;
}

Boolean SelectedEventUpdated() {
    declare netread Integer Net_EventsUI_SelectedEventUpdate for UI = -1;
    if (G_SelectedEventUpdate != Net_EventsUI_SelectedEventUpdate) {
        G_SelectedEventUpdate = Net_EventsUI_SelectedEventUpdate;
        return True;
    }
    return False;
}

main() {
    wait(Page != Null);

    InitEventsUpdater();
    InitSelectedEventUpdater();

    InitUIVars();

    declare Boolean HasLockedView = {{{Private_ViewIsLocked()}}};

    declare netread Integer Net_EventsUI_PlayerAmount for Teams[0] = 1;
    G_TotalPlayers = Net_EventsUI_PlayerAmount;
    
    declare netread K_VoteInfo Net_EventsUI_SelectedEventVote for UI;
    G_Vote = Net_EventsUI_SelectedEventVote;

    declare netread K_VoteInfo Net_EventsUI_QuitEventVote for UI;
    G_QuitEventVote = Net_EventsUI_QuitEventVote;

    while (True) {
        yield;

        if (EventsUpdated()) {
            UpdateEventList();
        }

        if (SelectedEventUpdated()) {
            UpdateSelectedEvent();
            UpdateSelectedEventUI();
        }

        if (Net_EventsUI_PlayerAmount != G_TotalPlayers) {
            G_TotalPlayers = Net_EventsUI_PlayerAmount;
            UpdateVoteBtnUI();
        }

        if (G_Vote != Net_EventsUI_SelectedEventVote) {
            G_Vote = Net_EventsUI_SelectedEventVote;
            UpdateVoteBtnUI();
        }

        if (G_QuitEventVote != Net_EventsUI_QuitEventVote) {
            G_QuitEventVote = Net_EventsUI_QuitEventVote;
            UpdateQuitEventVoteBtnUI();
        }

        UpdateFrameTab(UI, Page, "EventsUI", "Frame_EventsUI");

        foreach (Event in PendingEvents) {
            if (!(Event.Control is CMlQuad)
                || HasLockedView
                || Event.Control != Null
                    && Event.Control.DataAttributeExists("disabled")
                    && Event.Control.DataAttributeGet("disabled") != "0"
            ) {
                continue;
            }

            declare CMlQuad Quad <=> (Event.Control as CMlQuad);

            switch (Event.Type)  {
                case CMlScriptEvent::Type::MouseOver: {
                    if (Quad.DataAttributeExists("hover-opacity")) {
                        Quad.Opacity = TL::ToReal(Quad.DataAttributeGet("hover-opacity"));
                    } else {
                        Quad.Opacity = 1.;
                    }
                }

                case CMlScriptEvent::Type::MouseOut: {
                    Quad.Opacity = {{{C_ML_BtnOpacity}}};
                }

                case CMlScriptEvent::Type::MouseClick: {
                    HandleClick(Quad);
                }
            }
        }
    }
}

]]></script>
</manialink>
""";
}